신경망의 은닉 상태(hidden states) 를 희소(sparse)하고 이산(discrete) 한 형태로 만들기 위해 코드북(codebook) 구조를 도입

목표: 모델을 더 해석 가능하게 만들고, 원하는 행동을 직접 조작(control) 가능하게 하려는 것.

기존 신경망은 연속적인 벡터 표현을 사용하여 정보를 겹쳐(superposition) 담아내므로 해석이 어려움.

해결책: 각 레이어에 코드북 병목 구조(bottleneck) 를 삽입하여 신경망의 은닉 상태를 희소하고 이산적으로 변환.




요점:
코드북을 통해 토픽 중심 제어(topic-level control) 가 가능하다!

그냥 prompt에 의존하는 것보다 더 구조적이고 지속적인 제어가 가능함

Table 2. 코드북 모델도 여전히 성능이 좋다
이 표는 코드북이 들어간 모델이 기존 모델과 비교했을 때 얼마나 성능이 유지되는지를 보여줍니다.

코드북은 단지 "해석"만 가능한 게 아니라, 실제로 원하는 주제나 정보 방향으로 생성 텍스트를 조정할 수 있음

성능도 꽤 잘 유지되며, 작은 모델에서는 오히려 향상되기도 함

Figure 5는 실제 제어 사례 시각화, Table 2는 성능 보존 정량적 증
코드북 특징은, 네트워크 내부의 개념과 알고리즘을 더 쉽게 식별할 수 있도록,
은닉 상태를 희소하고 이산적인 형태로 리팩터링하는 방법을 제공

====================================
우리도 벡터 양자화(vector quantization) 를 활용하지만,
기존 연구와는 다르게, 우리는 다음과 같은 점에서 확장하였다:

우리는 이 방법을, 희소하고 이산적인 병목 구조로 활용하여
신경망의 모든 레이어 사이에 삽입할 수 있도록 일반화했으며,
이를 오토리그레시브 언어 모델에도 적용하였다.

그 결과, 네트워크의 중간 계산 과정에 대한 더 나은 이해와 제어가 가능해졌다.



우리의 연구는, 특정 토큰에 반응하는 코드를 기반으로,
네트워크 내부의 동작을 정확히 위치 추적(localize) 하는 것을 더 쉽게 만들고,


또한, 코드를 바꾸는 것만으로 개입할 수 있게 하여,
사용자가 각 층마다 크기를 달리한 벡터를 시도할 필요 없이 더 쉽게 조작할 수 있게 한다.

코드북 방식과 사전 학습 방식의 장단점에 대한 추가 논의는 부록 F에 포함되어 있다.

많은 코드가 결국 죽은 코드로 끝나지만, 코드 수를 너무 적게 시작하면 성능이 더 나빠진다.
→ 오히려 더 많은 코드로 시작하는 것이 낫다.
→ 이는 죽은 코드조차도 코드북 최적화 과정에서 일정한 역할을 수행하고 있음을 시사한다.
